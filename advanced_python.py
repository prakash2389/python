# -*- coding: utf-8 -*-
"""advanced_python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KC914ZnrR6zLSSlb_Ftvl7EGn3TttdHJ

## Advanced Python for Data Science

1. Advanced Functions
First-class functions

*args, **kwargs

Lambdas, map, filter, reduce

Closures & decorators

ðŸ”¹ 2. Comprehensions and Generators
List/dict/set comprehensions

Generator expressions

yield, yield from

ðŸ”¹ 3. Iterators & Iterable Protocol
Custom iterators using __iter__() and __next__()

Generator pipelines

Lazy loading with iterators

ðŸ”¹ 4. Advanced OOP Concepts
Dunder methods (__str__, __repr__, __len__, etc.)

Property decorators (@property)

Class methods vs static methods

Composition vs inheritance

ðŸ”¹ 5. Design Patterns in Python
Factory, Strategy, Singleton, Observer

Especially useful in pipeline or model architecture design

ðŸ”¹ 6. Type Hinting and Static Analysis
Using mypy, PEP 484, and typing module

Building maintainable and safer code

ðŸ”¹ 7. MetaProgramming
type(), getattr(), setattr(), hasattr()

Metaclasses for controlling class behavior

Use cases in ML frameworks

ðŸ”¹ 8. Concurrency & Parallelism
Threading vs multiprocessing

concurrent.futures

Asyncio (especially for API-heavy data ingestion)

ðŸ”¹ 9. Memory & Performance Optimization
__slots__

functools.lru_cache

Profiling with cProfile, line_profiler, memory_profiler

Numba, Cython for fast math

ðŸ”¹ 10. Effective Use of Libraries
Deep usage of pandas, NumPy (views, broadcasting, memory models)

Custom pandas accessors and methods

Vectorization techniques

## Closures & Decorators
"""

def log_function(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@log_function
def greet(name):
    print(f"Hello, {name}")
@log_function
def thanks(name):
    print(f"Thank you, {name}")

greet("Prakash")
thanks("Prakash")



def multiplier(factor):
    def multiply_by(x):
        return x * factor
    return multiply_by

result = multiplier(5)

result(4)

"""## Custom Iterator"""

class Countdown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        value = self.current
        self.current -= 1
        return value

for i in Countdown(6):
  print(i)

