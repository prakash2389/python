# -*- coding: utf-8 -*-
"""Class Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V1GnuRAUSil777vALdOKcsIxJex6Yj9N

# **Class**
"""

class person:
  def __init__(self, name, age, gender):
    self.name = name
    self.age = age
    self.gender = gender
  def height(self, height):
    self.height = height
  def weight(self, weight):
    self.weight = weight
  def bmi(self):
    return self.weight / (self.height ** 2)

prakash = person("prakash","34", "M")

print(prakash.age, prakash.name, prakash.gender)

prakash.height(1.72)

prakash.height

prakash.weight(80)

prakash.bmi()

"""# **Person is Base class and lets create subclass**
# **3. Inheritance in Python**
"""

class crickter(person):
  def height(self, height):
    self.height = height*2
  def weight(self, weight):
    self.weight = weight*2
  def bmi(self):
    return self.weight / self.height

p = crickter("prakash", 34, "M")

p.weight(80)

p.height(1.72)

p.weight

p.bmi()

"""__init__() is a constructor — runs automatically when the object is created.

self refers to the current object.

# **2. Encapsulation in Python**
# Encapsulation hides internal object details from the outside world. **bold text**
"""

class Account():
  def __init__(self, name, balance):
    self.name = name
    self.__balance = balance
  def deposit(self, amount):
    self.__balance += amount
  def withdraw(self, amount):
    self.__balance -= amount
  def get_balance(self):
    return self.__balance

sbi = Account("prakash", 100000)

sbi.name

sbi.__balance
# In Python, prefixing an attribute with double underscores (__) makes it a "private" attribute. This means it's intended for internal use within the class and is not directly accessible from outside the class.

sbi.deposit(10000)

sbi.withdraw(5000)

sbi.get_balance()



"""# *4. Polymorphism in Python*
# Same interface, different behavior — useful in interfaces and extensible systems.
"""

class Bike():
  def wheels(self):
    return 2
class Car():
  def wheels(self):
    return 4

def Vehicle(vehical_type):
  return vehical_type.wheels()

print(Vehicle(Car()))

m=Car()



m.wheels

"""### SKLEARN"""

class ModelChoose():
  def Model_Call(self, modelname):
    if modelname == "logistic":
      from sklearn.linear_model import LogisticRegression
      return LogisticRegression()
    elif modelname == "randomforest":
      from sklearn.ensemble import RandomForestClassifier
      return RandomForestClassifier()
    else:
      return "Unknown Model given"

model =ModelChoose().Model_Call("logistic")





import numpy as np

model.fit(np.array([2,4,6,7,10]).reshape(-1,1),[0,1,2,3,4])

from sklearn.metrics import mean_squared_error
mean_squared_error(model.predict(np.array([2,4,6,7,10]).reshape(-1,1)), [0,1,2,3,4])

